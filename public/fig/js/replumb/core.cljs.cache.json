["^ ","~:use-macros",["^ ","~$with-compiler-env","~$cljs.env.macros"],"~:excludes",["~#set",[]],"~:name","~$replumb.core","~:imports",null,"~:requires",["^ ","~$cljs","~$cljs.js","^:","^:","~$repl","~$replumb.repl","^<","^<","~$common","~$replumb.common","^>","^>"],"~:uses",null,"~:defs",["^ ","~$read-eval-call",["^ ","~:protocol-inline",null,"~:meta",["^ ","~:file","/Users/yehonathan.sharvit/prj/klipse/resources/public/fig/js/replumb/core.cljs","~:line",8,"~:column",16,"~:end-line",8,"~:end-column",30,"~:export",true,"~:arglists",["~#list",["~$quote",["^K",[["~$callback","~$source"],["~$opts","^M","^N"]]]]],"~:doc","Reads, evaluates and calls back with the evaluation result.\n\n  The first parameter is a map of configuration options, currently\n  supporting:\n\n  * `:verbose` will enable the the evaluation logging, defaults to false.\n  To customize how to print, use `(set! *print-fn* (fn [& args] ...)`\n\n  * `:warning-as-error` will consider a compiler warning as error.\n\n  * `:target` `:nodejs` and `:browser` supported, the latter is used if\n  missing.\n\n  * `:init-fn!` user provided initialization function, it will be passed a\n  map:\n\n          :form   ;; the form to evaluate, as data\n          :ns     ;; the current namespace, as symbol\n          :target ;; the current target\n\n  * `:load-fn!` will override replumb's default `cljs.js/*load-fn*`.\n  It rules out `:read-file-fn!`, losing any perk of using `replumb.load`\n  helpers. Trickily enough, `:load-fn!` is never used with `load-file`. It is the\n  only case where it does not take precedence over `:read-file-fn!`. Use it if\n  you know what you are doing and follow this protocol:\n\n      ```\n      Each runtime environment provides a different way to load a library.\n      Whatever function `*load-fn*` is bound to will be passed two arguments\n      - a map and a callback function: The map will have the following keys:\n\n          :name   - the name of the library (a symbol)\n          :macros - modifier signaling a macros namespace load\n          :path   - munged relative library path (a string)\n\n      The callback cb, upon resolution, will need to pass the same map:\n\n          :lang       - the language, :clj or :js\n          :source     - the source of the library (a string)\n          :cache      - optional, if a :clj namespace has been precompiled to\n                        :js, can give an analysis cache for faster loads.\n          :source-map - optional, if a :clj namespace has been precompiled\n                        to :js, can give a V3 source map JSON\n\n      If the resource could not be resolved, the callback should be invoked with\n      nil.\n      ```\n\n  * `:read-file-fn!` an asynchronous 2-arity function with signature\n  `[file-path src-cb]` where src-cb is itself a function `(fn [source]\n  ...)` that needs to be called with the file content as string (`nil`\n  if no file is found). It is mutually exclusive with `:load-fn!` and\n  will be ignored in case both are present.\n\n  * `:write-file-fn!` a synchronous 2-arity function with signature\n  `[file-path data]` that accepts a file-path and data to write.\n\n  * `:src-paths` - a vector of paths containing source files.\n\n  * `:cache` - a map containing two optional values: the first, `:path`,\n  indicates the path of the cached files. The second, `:src-paths-lookup?`,\n  indicates whether search the cached files in `:src-paths`. If both present,\n  `:path` will have the priority but both will be inspected.\n\n  * `:no-pr-str-on-value`  in case of `:success?` avoid converting the\n  result map `:value` to string.\n\n  * `:context` - indicates the evaluation context that will be passed to\n  `cljs/eval-str`. One in `:expr`, `:statement`, `:return`. Defaults to `:expr`.\n  If you really feel adventurous check [David Nolen's dev notes](https://github.com/clojure/clojurescript/blob/r1.7.228/devnotes/day1.org#tricky-bit---context).\n\n  * `:foreign-libs` - a way to include foreign libraries. The format is analogous\n  to the compiler option. For more info visit the [compiler options page](https://github.com/clojure/clojurescript/wiki/Compiler-Options#foreign-libs).\n\n  * `:static-fns` - static dispatch in generated JavaScript. See the\n  [compiler option page](https://github.com/clojure/clojurescript/wiki/Compiler-Options#static-fns).\n\n  The second parameter, `callback`, should be a 1-arity function which receives\n  the result map, whose result keys will be:\n\n  ```\n  :success?  a boolean indicating if everything went alright\n  :value     (if (:success? result)), this key contains the yielded value as\n             string, unless :no-pr-str-on-value is true, in which case it\n             returns the bare value.\n  :error     (if-not (:success? result)) will contain a js/Error\n  :warning   in case a warning was thrown and :warning-as-error is falsey\n  :form      the evaluated form as data structure (not string)}\n  ```\n\n  The third parameter is the source string to be read and evaluated.","~:top-fn",["^ ","~:variadic",false,"~:max-fixed-arity",3,"~:method-params",["^K",[["^M","^N"],["^O","^M","^N"]]],"^J",["^K",[["^M","^N"],["^O","^M","^N"]]],"~:arglists-meta",["^K",[null,null]]]],"^5","~$replumb.core/read-eval-call","^R",false,"^D","resources/public/fig/js/replumb/core.cljs","^H",30,"^Q",["^ ","^R",false,"^S",3,"^T",["^K",[["^M","^N"],["^O","^M","^N"]]],"^J",["^K",[["^M","^N"],["^O","^M","^N"]]],"^U",["^K",[null,null]]],"^T",["^K",[["^M","^N"],["^O","^M","^N"]]],"~:protocol-impl",null,"^I",true,"^U",["^K",[null,null]],"^F",1,"^E",8,"^G",8,"^S",3,"~:fn-var",true,"^J",["^K",[["^M","^N"],["^O","^M","^N"]]],"^P","Reads, evaluates and calls back with the evaluation result.\n\n  The first parameter is a map of configuration options, currently\n  supporting:\n\n  * `:verbose` will enable the the evaluation logging, defaults to false.\n  To customize how to print, use `(set! *print-fn* (fn [& args] ...)`\n\n  * `:warning-as-error` will consider a compiler warning as error.\n\n  * `:target` `:nodejs` and `:browser` supported, the latter is used if\n  missing.\n\n  * `:init-fn!` user provided initialization function, it will be passed a\n  map:\n\n          :form   ;; the form to evaluate, as data\n          :ns     ;; the current namespace, as symbol\n          :target ;; the current target\n\n  * `:load-fn!` will override replumb's default `cljs.js/*load-fn*`.\n  It rules out `:read-file-fn!`, losing any perk of using `replumb.load`\n  helpers. Trickily enough, `:load-fn!` is never used with `load-file`. It is the\n  only case where it does not take precedence over `:read-file-fn!`. Use it if\n  you know what you are doing and follow this protocol:\n\n      ```\n      Each runtime environment provides a different way to load a library.\n      Whatever function `*load-fn*` is bound to will be passed two arguments\n      - a map and a callback function: The map will have the following keys:\n\n          :name   - the name of the library (a symbol)\n          :macros - modifier signaling a macros namespace load\n          :path   - munged relative library path (a string)\n\n      The callback cb, upon resolution, will need to pass the same map:\n\n          :lang       - the language, :clj or :js\n          :source     - the source of the library (a string)\n          :cache      - optional, if a :clj namespace has been precompiled to\n                        :js, can give an analysis cache for faster loads.\n          :source-map - optional, if a :clj namespace has been precompiled\n                        to :js, can give a V3 source map JSON\n\n      If the resource could not be resolved, the callback should be invoked with\n      nil.\n      ```\n\n  * `:read-file-fn!` an asynchronous 2-arity function with signature\n  `[file-path src-cb]` where src-cb is itself a function `(fn [source]\n  ...)` that needs to be called with the file content as string (`nil`\n  if no file is found). It is mutually exclusive with `:load-fn!` and\n  will be ignored in case both are present.\n\n  * `:write-file-fn!` a synchronous 2-arity function with signature\n  `[file-path data]` that accepts a file-path and data to write.\n\n  * `:src-paths` - a vector of paths containing source files.\n\n  * `:cache` - a map containing two optional values: the first, `:path`,\n  indicates the path of the cached files. The second, `:src-paths-lookup?`,\n  indicates whether search the cached files in `:src-paths`. If both present,\n  `:path` will have the priority but both will be inspected.\n\n  * `:no-pr-str-on-value`  in case of `:success?` avoid converting the\n  result map `:value` to string.\n\n  * `:context` - indicates the evaluation context that will be passed to\n  `cljs/eval-str`. One in `:expr`, `:statement`, `:return`. Defaults to `:expr`.\n  If you really feel adventurous check [David Nolen's dev notes](https://github.com/clojure/clojurescript/blob/r1.7.228/devnotes/day1.org#tricky-bit---context).\n\n  * `:foreign-libs` - a way to include foreign libraries. The format is analogous\n  to the compiler option. For more info visit the [compiler options page](https://github.com/clojure/clojurescript/wiki/Compiler-Options#foreign-libs).\n\n  * `:static-fns` - static dispatch in generated JavaScript. See the\n  [compiler option page](https://github.com/clojure/clojurescript/wiki/Compiler-Options#static-fns).\n\n  The second parameter, `callback`, should be a 1-arity function which receives\n  the result map, whose result keys will be:\n\n  ```\n  :success?  a boolean indicating if everything went alright\n  :value     (if (:success? result)), this key contains the yielded value as\n             string, unless :no-pr-str-on-value is true, in which case it\n             returns the bare value.\n  :error     (if-not (:success? result)) will contain a js/Error\n  :warning   in case a warning was thrown and :warning-as-error is falsey\n  :form      the evaluated form as data structure (not string)}\n  ```\n\n  The third parameter is the source string to be read and evaluated."],"~$get-prompt",["^ ","^B",null,"^C",["^ ","^D","/Users/yehonathan.sharvit/prj/klipse/resources/public/fig/js/replumb/core.cljs","^E",103,"^F",16,"^G",103,"^H",26,"^I",true,"^J",["^K",["^L",["^K",[[]]]]],"^P","Retrieves the REPL prompt to display, according to the current\n  namespace. Returns a string."],"^5","~$replumb.core/get-prompt","^R",false,"^D","resources/public/fig/js/replumb/core.cljs","^H",26,"^T",["^K",[[]]],"^W",null,"^I",true,"^U",["^K",[null,null]],"^F",1,"^E",103,"^G",103,"^S",0,"^X",true,"^J",["^K",["^L",["^K",[[]]]]],"^P","Retrieves the REPL prompt to display, according to the current\n  namespace. Returns a string."],"~$error->str",["^ ","^B",null,"^C",["^ ","^D","/Users/yehonathan.sharvit/prj/klipse/resources/public/fig/js/replumb/core.cljs","^E",109,"^F",16,"^G",109,"^H",26,"^I",true,"^J",["^K",["^L",["^K",[["~$error"],["~$print-stack?","^10"]]]]],"^P","Return the message string of the input `js/Error`.","^Q",["^ ","^R",false,"^S",2,"^T",["^K",[["^10"],["^11","^10"]]],"^J",["^K",[["^10"],["^11","^10"]]],"^U",["^K",[null,null]]]],"^5","~$replumb.core/error->str","^R",false,"^D","resources/public/fig/js/replumb/core.cljs","^H",26,"^Q",["^ ","^R",false,"^S",2,"^T",["^K",[["^10"],["^11","^10"]]],"^J",["^K",[["^10"],["^11","^10"]]],"^U",["^K",[null,null]]],"^T",["^K",[["^10"],["^11","^10"]]],"^W",null,"^I",true,"^U",["^K",[null,null]],"^F",1,"^E",109,"^G",109,"^S",2,"^X",true,"^J",["^K",[["^10"],["^11","^10"]]],"^P","Return the message string of the input `js/Error`."],"~$unwrap-result",["^ ","^B",null,"^C",["^ ","^D","/Users/yehonathan.sharvit/prj/klipse/resources/public/fig/js/replumb/core.cljs","^E",114,"^F",16,"^G",114,"^H",29,"^I",true,"^J",["^K",["^L",["^K",[["~$result-map"],["~$include-warning?","^14"]]]]],"^P","Unwraps the result of an evaluation.\n\n  It returns the content of `:value` in case of success and the content\n  of `:error` (a `js/Error`) in case of failure.\n\n  When `include-warning?` is true, then the string returned is, in\n  order, from the `:error`, `:warning` and eventually `:value` key in\n  the result map.","^Q",["^ ","^R",false,"^S",2,"^T",["^K",[["^14"],["^15","^14"]]],"^J",["^K",[["^14"],["^15","^14"]]],"^U",["^K",[null,null]]]],"^5","~$replumb.core/unwrap-result","^R",false,"^D","resources/public/fig/js/replumb/core.cljs","^H",29,"^Q",["^ ","^R",false,"^S",2,"^T",["^K",[["^14"],["^15","^14"]]],"^J",["^K",[["^14"],["^15","^14"]]],"^U",["^K",[null,null]]],"^T",["^K",[["^14"],["^15","^14"]]],"^W",null,"^I",true,"^U",["^K",[null,null]],"^F",1,"^E",114,"^G",114,"^S",2,"^X",true,"^J",["^K",[["^14"],["^15","^14"]]],"^P","Unwraps the result of an evaluation.\n\n  It returns the content of `:value` in case of success and the content\n  of `:error` (a `js/Error`) in case of failure.\n\n  When `include-warning?` is true, then the string returned is, in\n  order, from the `:error`, `:warning` and eventually `:value` key in\n  the result map."],"~$success?",["^ ","^B",null,"^C",["^ ","^D","/Users/yehonathan.sharvit/prj/klipse/resources/public/fig/js/replumb/core.cljs","^E",133,"^F",16,"^G",133,"^H",24,"^I",true,"^J",["^K",["^L",["^K",[["^14"]]]]],"^P","Given a `result-map`, tells whether the evaluation was successful."],"^5","~$replumb.core/success?","^R",false,"^D","resources/public/fig/js/replumb/core.cljs","^H",24,"^T",["^K",[["^14"]]],"^W",null,"^I",true,"^U",["^K",[null,null]],"^F",1,"^E",133,"^G",133,"^S",1,"^X",true,"^J",["^K",["^L",["^K",[["^14"]]]]],"^P","Given a `result-map`, tells whether the evaluation was successful."],"~$result->string",["^ ","^B",null,"^C",["^ ","^D","/Users/yehonathan.sharvit/prj/klipse/resources/public/fig/js/replumb/core.cljs","^E",138,"^F",16,"^G",138,"^H",30,"^I",true,"^J",["^K",["^L",["^K",[["^14"],["^11","^14"],["^11","^15","^14"]]]]],"^P","Given a `result-map`, returns the result of the evaluation as string.\n\n  - When `include-warning?` is true, then the string returned is, in\n  order, from the `:error`, `:warning` and eventually `:value` key in\n  the result map.\n\n  - When `print-stack?` is true, the error string will include the stack\n  trace.","^Q",["^ ","^R",false,"^S",3,"^T",["^K",[["^14"],["^11","^14"],["^11","^15","^14"]]],"^J",["^K",[["^14"],["^11","^14"],["^11","^15","^14"]]],"^U",["^K",[null,null,null]]]],"^5","~$replumb.core/result->string","^R",false,"^D","resources/public/fig/js/replumb/core.cljs","^H",30,"^Q",["^ ","^R",false,"^S",3,"^T",["^K",[["^14"],["^11","^14"],["^11","^15","^14"]]],"^J",["^K",[["^14"],["^11","^14"],["^11","^15","^14"]]],"^U",["^K",[null,null,null]]],"^T",["^K",[["^14"],["^11","^14"],["^11","^15","^14"]]],"^W",null,"^I",true,"^U",["^K",[null,null,null]],"^F",1,"^E",138,"^G",138,"^S",3,"^X",true,"^J",["^K",[["^14"],["^11","^14"],["^11","^15","^14"]]],"^P","Given a `result-map`, returns the result of the evaluation as string.\n\n  - When `include-warning?` is true, then the string returned is, in\n  order, from the `:error`, `:warning` and eventually `:value` key in\n  the result map.\n\n  - When `print-stack?` is true, the error string will include the stack\n  trace."],"~$options",["^ ","^B",null,"^C",["^ ","^D","/Users/yehonathan.sharvit/prj/klipse/resources/public/fig/js/replumb/core.cljs","^E",160,"^F",16,"^G",160,"^H",23,"^I",true,"^J",["^K",["^L",["^K",[["~$target","~$load-fn!"],["^1<","~$src-paths","~$read-file-fn!"],["^1<","^1>","^1?","~$write-file-fn!"]]]]],"^P","Creates the right option map for read-eval-call.\n\n  Supported targets: `:nodejs` or `:node`, `:browser`. It throws if not\n  supported.\n\n  The 2-arity function requires a `load-fn!` compatible with\n  ClojureScript `cljs.js/*load-fn*`. Use it if you know what you are\n  doing and follow this protocol:\n\n      Each runtime environment provides a different way to load a library.\n      Whatever function `*load-fn*` is bound to will be passed two arguments\n      - a map and a callback function: The map will have the following keys:\n\n          :name   - the name of the library (a symbol)\n          :macros - modifier signaling a macros namespace load\n          :path   - munged relative library path (a string)\n\n      The callback cb, upon resolution, will need to pass the same map:\n\n          :lang       - the language, :clj or :js\n          :source     - the source of the library (a string)\n          :cache      - optional, if a :clj namespace has been precompiled to\n                        :js, can give an analysis cache for faster loads.\n          :source-map - optional, if a :clj namespace has been precompiled\n                        to :js, can give a V3 source map JSON\n\n      If the resource could not be resolved, the callback should be invoked with\n      nil.\n\n  The 3-arity function accepts a sequence of source path strings and\n  `read-file-fn!`, an asynchronous 2-arity function with signature\n  `[file-path src-cb]` where src-cb is itself a function `(fn [source]\n  ...)` that needs to be called with the file content as string (`nil`\n  if no file is found).\n\n  The 4-arity function receives additionally a fourth parameter `write-file-fn!`,\n  a synchronous 2-arity function with signature `[file-path data]` that accepts\n  a file-path and data to write.","^Q",["^ ","^R",false,"^S",4,"^T",["^K",[["^1<","^1="],["^1<","^1>","^1?"],["^1<","^1>","^1?","^1@"]]],"^J",["^K",[["^1<","^1="],["^1<","^1>","^1?"],["^1<","^1>","^1?","^1@"]]],"^U",["^K",[null,null,null]]]],"^5","~$replumb.core/options","^R",false,"^D","resources/public/fig/js/replumb/core.cljs","^H",23,"^Q",["^ ","^R",false,"^S",4,"^T",["^K",[["^1<","^1="],["^1<","^1>","^1?"],["^1<","^1>","^1?","^1@"]]],"^J",["^K",[["^1<","^1="],["^1<","^1>","^1?"],["^1<","^1>","^1?","^1@"]]],"^U",["^K",[null,null,null]]],"^T",["^K",[["^1<","^1="],["^1<","^1>","^1?"],["^1<","^1>","^1?","^1@"]]],"^W",null,"^I",true,"^U",["^K",[null,null,null]],"^F",1,"^E",160,"^G",160,"^S",4,"^X",true,"^J",["^K",[["^1<","^1="],["^1<","^1>","^1?"],["^1<","^1>","^1?","^1@"]]],"^P","Creates the right option map for read-eval-call.\n\n  Supported targets: `:nodejs` or `:node`, `:browser`. It throws if not\n  supported.\n\n  The 2-arity function requires a `load-fn!` compatible with\n  ClojureScript `cljs.js/*load-fn*`. Use it if you know what you are\n  doing and follow this protocol:\n\n      Each runtime environment provides a different way to load a library.\n      Whatever function `*load-fn*` is bound to will be passed two arguments\n      - a map and a callback function: The map will have the following keys:\n\n          :name   - the name of the library (a symbol)\n          :macros - modifier signaling a macros namespace load\n          :path   - munged relative library path (a string)\n\n      The callback cb, upon resolution, will need to pass the same map:\n\n          :lang       - the language, :clj or :js\n          :source     - the source of the library (a string)\n          :cache      - optional, if a :clj namespace has been precompiled to\n                        :js, can give an analysis cache for faster loads.\n          :source-map - optional, if a :clj namespace has been precompiled\n                        to :js, can give a V3 source map JSON\n\n      If the resource could not be resolved, the callback should be invoked with\n      nil.\n\n  The 3-arity function accepts a sequence of source path strings and\n  `read-file-fn!`, an asynchronous 2-arity function with signature\n  `[file-path src-cb]` where src-cb is itself a function `(fn [source]\n  ...)` that needs to be called with the file content as string (`nil`\n  if no file is found).\n\n  The 4-arity function receives additionally a fourth parameter `write-file-fn!`,\n  a synchronous 2-arity function with signature `[file-path data]` that accepts\n  a file-path and data to write."],"~$repl-reset!",["^ ","^B",null,"^C",["^ ","^D","/Users/yehonathan.sharvit/prj/klipse/resources/public/fig/js/replumb/core.cljs","^E",218,"^F",7,"^G",218,"^H",18,"^J",["^K",["^L",["^K",[["^O"]]]]],"^P","Reset the repl and the current compiler state.\n\n  It performs the following (in order):\n\n  1. removes `cljs.js/*loaded*` namespaces from the compiler environment\n  2. calls `(read-eval-call (in-ns 'cljs.user))`\n  3. resets the last warning\n  4. sets `*e` to nil\n  5. resets the init options (the next eval will trigger an init)"],"^5","~$replumb.core/repl-reset!","^R",false,"^D","resources/public/fig/js/replumb/core.cljs","^H",18,"^T",["^K",[["^O"]]],"^W",null,"^U",["^K",[null,null]],"^F",1,"^E",218,"^G",218,"^S",1,"^X",true,"^J",["^K",["^L",["^K",[["^O"]]]]],"^P","Reset the repl and the current compiler state.\n\n  It performs the following (in order):\n\n  1. removes `cljs.js/*loaded*` namespaces from the compiler environment\n  2. calls `(read-eval-call (in-ns 'cljs.user))`\n  3. resets the last warning\n  4. sets `*e` to nil\n  5. resets the init options (the next eval will trigger an init)"]],"~:require-macros",["^ ","^2","^2","^9","^:","^:","^:"],"~:cljs.analyzer/constants",["^ ","~:seen",["^4",["~:read-file-fn!","~:default","~:value","~:write-file-fn!","~:nodejs","~:warning","~:error","~:load-fn!","~:target","~:success?","~:src-paths"]],"~:order",["^1M","^1I","^1L","^1P","^1O","^1N","^1K","^1H","^1G","^1Q","^1J"]],"^P","Replumb core functions for self-hosted ClojureScript REPL implementations"]